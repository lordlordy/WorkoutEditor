//
//  JSONImporter.swift
//  WorkoutEditor
//
//  Created by Steven Lord on 09/09/2019.
//  Copyright Â© 2019 Steven Lord. All rights reserved.
//

import Foundation

class JSONImporter{
    
    private var progressUpdater: ((Double, String) -> Void)?
    private var timeFormatter: DateComponentsFormatter = DateComponentsFormatter()
    private var df: DateFormatter = DateFormatter()
    
    init(progressUpdater updater: ((Double, String) -> Void)?){
        progressUpdater = updater
        
        timeFormatter.allowedUnits = [.hour, .minute, .second]
        timeFormatter.unitsStyle = .positional
        timeFormatter.zeroFormattingBehavior = .pad
    
        df.dateFormat = "yyyy-MM-dd"
    }
    
    public func importDiary(fromURL url: URL, intoTrainingDiary td: TrainingDiary){
        let start: Date = Date()
        do{
            let data: Data = try Data.init(contentsOf: url)
            let jsonData  = try JSONSerialization.jsonObject(with: data, options: [.allowFragments, .mutableContainers])
            
            if let jsonDict = jsonData as? [String:Any]{
                if let version = jsonDict["JSONVersion"] as? String{
                    // have version number
                    if version == JSONExporter.currentVersion{
                        importDaysWorkoutEditorV1(jsonDict: jsonDict, intoTrainingDiary: td, start: start)
                    }
                }else if let createdBy = jsonDict["Generated By"] as? String{
                    // don't have version number. This is created by old diary
                    if createdBy == "SwiftTrainingDiary"{
                        importSwiftTrainingDiaryJSON(jsonDict: jsonDict, intoTrainingDiary: td, start: start)
                    }
                }
            }

        } catch {
            print("Unable to retrieve contents of \(url)")
            print(error)
        }
        print("import took \(Int(Date().timeIntervalSince(start)))s")

    }
    
    private func importDaysWorkoutEditorV1(jsonDict: [String: Any], intoTrainingDiary td: TrainingDiary, start: Date){
        
        guard let days = jsonDict["Days"] as? [[String:Any]] else{
            print("Dictionary not of type [[String: Any]]: \(jsonDict)")
            return
        }
        var progress: Double = 0.0
        let total: Double = Double(days.count)
        for d in days{
            progress += 1.0
            let day: Day = Day(date: df.date(from: d[DayJSONProperty.iso8601DateString.rawValue] as! String)!, type: d[DayJSONProperty.type.rawValue] as! String, comments: d[DayJSONProperty.comments.rawValue] as! String, trainingDiary: td)
            WorkoutDBAccess.shared.save(day: day)
            if let workouts = d["Workouts"] as? [[String:Any]]{
                var wNumber: Int = 1
                for w in workouts{
                    let workout: Workout = Workout(day: day,
                                                   workout_number: wNumber,
                                                   activity: w[WorkoutJSONProperty.activity.rawValue] as! String,
                                                   activity_type: w[WorkoutJSONProperty.activityType.rawValue] as! String,
                                                   equipment: w[WorkoutJSONProperty.equipment.rawValue] as! String,
                                                   seconds: w[WorkoutJSONProperty.seconds.rawValue] as! Int,
                                                   rpe: w[WorkoutJSONProperty.rpe.rawValue] as! Double,
                                                   tss: w[WorkoutJSONProperty.tss.rawValue] as! Int,
                                                   tss_method: w[WorkoutJSONProperty.tssMethod.rawValue] as! String,
                                                   km: w[WorkoutJSONProperty.km.rawValue] as! Double,
                                                   kj: w[WorkoutJSONProperty.kj.rawValue] as! Int,
                                                   ascent_metres: w[WorkoutJSONProperty.ascentMetres.rawValue] as! Int,
                                                   reps: w[WorkoutJSONProperty.reps.rawValue] as! Int,
                                                   is_race: w[WorkoutJSONProperty.isRace.rawValue] as! Int > 0,
                                                   cadence: w[WorkoutJSONProperty.cadence.rawValue] as! Int,
                                                   watts: w[WorkoutJSONProperty.watts.rawValue] as! Int,
                                                   watts_estimated: w[WorkoutJSONProperty.wattsEstimated.rawValue] as! Int > 0,
                                                   heart_rate: w[WorkoutJSONProperty.heartRate.rawValue] as! Int,
                                                   is_brick: w[WorkoutJSONProperty.isBrick.rawValue] as! Int > 0,
                                                   keywords: w[WorkoutJSONProperty.keywords.rawValue] as! String,
                                                   comments: w[WorkoutJSONProperty.comments.rawValue] as! String)
                    WorkoutDBAccess.shared.save(workout: workout)
                    wNumber += 1
                }
            }
            if let readings = d["Readings"] as? [[String:Any]]{
                for r in readings{
                    let reading: Reading = Reading(type: r[ReadingJSONProperty.type.rawValue] as! String, value: r[ReadingJSONProperty.value.rawValue] as! Double, parent: day)
                    WorkoutDBAccess.shared.save(reading: reading)
                }
            }
            if let p = progressUpdater{
                p(progress / total, progressString(percentage: progress / total, start: start))
            }
        }
        
        for r in jsonDict["RaceResults"] as? [[String:Any]] ?? []{
            let rr: RaceResult = RaceResult(date: df.date(from: r[RaceResultJSONProperty.iso8601DateString.rawValue] as! String)!,
                                            raceNumber: r[RaceResultJSONProperty.raceNumber.rawValue] as! Int,
                                            type: r[RaceResultJSONProperty.type.rawValue] as! String,
                                            brand: r[RaceResultJSONProperty.brand.rawValue] as! String,
                                            distance: r[RaceResultJSONProperty.distance.rawValue] as! String,
                                            name: r[RaceResultJSONProperty.name.rawValue] as! String,
                                            category: r[RaceResultJSONProperty.category.rawValue] as! String,
                                            overallPosition: r[RaceResultJSONProperty.overallPosition.rawValue] as! Int,
                                            categoryPosition: r[RaceResultJSONProperty.categoryPosition.rawValue] as! Int,
                                            swimSeconds: r[RaceResultJSONProperty.swimSeconds.rawValue] as! Int,
                                            t1Seconds: r[RaceResultJSONProperty.t1Seconds.rawValue] as! Int,
                                            bikeSeconds: r[RaceResultJSONProperty.bikeSeconds.rawValue] as! Int,
                                            t2Seconds: r[RaceResultJSONProperty.t2Seconds.rawValue] as! Int,
                                            runSeconds: r[RaceResultJSONProperty.runSeconds.rawValue] as! Int,
                                            swimKM: r[RaceResultJSONProperty.swimKM.rawValue] as! Double,
                                            bikeKM: r[RaceResultJSONProperty.bikeKM.rawValue] as! Double,
                                            runKM: r[RaceResultJSONProperty.runKM.rawValue] as! Double,
                                            comments: r[RaceResultJSONProperty.comments.rawValue] as! String,
                                            raceReport: r[RaceResultJSONProperty.raceReport.rawValue] as! String)
            WorkoutDBAccess.shared.save(raceResult: rr)
        }
        
    }
    
    private func importSwiftTrainingDiaryJSON(jsonDict: [String: Any], intoTrainingDiary td: TrainingDiary, start: Date){

        var total: Double = Double((jsonDict["days"] as? [Any])?.count ?? 0)
        total += Double((jsonDict["weights"] as? [Any])?.count ?? 0)
        total += Double((jsonDict["physiologicals"] as? [Any])?.count ?? 0)
        var progress: Double = 0.0

        if let days = jsonDict["days"] as? [[String:Any]]{
            for d in days{
                guard  let dString: String = d["iso8601DateString"] as? String else {
                    continue
                }
               
                let day: Day = Day(date: ISO8601DateFormatter().date(from: dString)!, type: d["type"] as! String, comments: d["comments"] as? String ?? "", trainingDiary: td)
                if Calendar.current.compare(day.date, to: Calendar.current.date(from: DateComponents(year: 2005, month: 01, day: 02))!, toGranularity: .day) == ComparisonResult.orderedSame{
                    print("found that date")
                }
                WorkoutDBAccess.shared.save(day: day)
                WorkoutDBAccess.shared.save(reading: Reading(type: "sleep", value: d["sleep"] as! Double, parent: day))
                WorkoutDBAccess.shared.save(reading: Reading(type: "fatigue", value: d["fatigue"] as! Double, parent: day))
                WorkoutDBAccess.shared.save(reading: Reading(type: "motivation", value: d["motivation"] as! Double, parent: day))
                WorkoutDBAccess.shared.save(reading: Reading(type: "sleepQualityScore", value: sleepQualityScore(forQuality: d["sleepQuality"] as! String), parent: day))

                if let workouts = d["workouts"] as? [[String:Any]]{
                    var workout_number: Int = 1
                    for w in workouts{
                        let wOut = workout(fromDict: w, andDay: day, workout_number: workout_number)
                        WorkoutDBAccess.shared.save(workout: wOut)
                        day.add(workout: wOut)
                        workout_number += 1
                    }
                }
                progress += 1.0
                if let p = progressUpdater{
                    p(progress / total, "Importing days... \(dString) \(progressString(percentage: progress / total, start: start))")
                }
            }
        }
        
        if let weights = jsonDict["weights"] as? [[String:Any]]{
            for w in weights{
                // just set up dummy day for the save
                let dString: String = w["iso8061DateString"] as! String
                let day: Day = Day(date: ISO8601DateFormatter().date(from: dString)!, type: "", comments: "", trainingDiary: td)
                
                WorkoutDBAccess.shared.save(reading: Reading(type: "kg", value: w["kg"] as! Double, parent: day))
                WorkoutDBAccess.shared.save(reading: Reading(type: "fatPercentage", value: w["fatPercent"] as! Double, parent: day))
                progress += 1.0
                if let p = progressUpdater{
                    p(progress / total, "Importing weights... \(dString) \(progressString(percentage: progress / total, start: start))")
                }
            }
        }

        if let physiologicals = jsonDict["physiologicals"] as? [[String:Any]]{
            for physio in physiologicals{
                let dString: String = physio["iso8061DateString"] as! String
                // just set up dummy day for the save
                let day: Day = Day(date: ISO8601DateFormatter().date(from: dString)!, type: "", comments: "", trainingDiary: td)
                
                WorkoutDBAccess.shared.save(reading: Reading(type: "restingHR", value: physio["restingHR"] as! Double, parent: day))
                if let rmssd = physio["restingRMSSD"] as? Double{
                    WorkoutDBAccess.shared.save(reading: Reading(type: "rMSSD", value: rmssd, parent: day))
                }
                if let sdnn = physio["restingSDNN"] as? Double{
                    WorkoutDBAccess.shared.save(reading: Reading(type: "SDNN", value: sdnn, parent: day))
                }
                progress += 1.0
                if let p = progressUpdater{
                    p(progress / total, "Importing physiologicals... \(dString) \(progressString(percentage: progress / total, start: start))")
                }
            }
        }
    }
    
    private func workout(fromDict dict: [String: Any], andDay day: Day, workout_number: Int) -> Workout{
        var equip: String = ""
        if let e = dict["equipmentName"] as? String{
            if e != "Not Set"{
                equip = e
            }
        }
        return Workout(day: day,
                       workout_number: workout_number,
                       activity: dict["activityString"] as! String,
                       activity_type: dict["activityTypeString"] as! String,
                       equipment: equip,
                       seconds: dict["seconds"] as! Int,
                       rpe: dict["rpe"] as! Double,
                       tss: Int(dict["tss"] as! Double),
                       tss_method: dict["tssMethod"] as! String,
                       km: dict["km"] as! Double,
                       kj: Int(dict["kj"] as! Double),
                       ascent_metres: Int(dict["ascentMetres"] as! Double),
                       reps: dict["reps"] as! Int,
                       is_race: (dict["isRace"] as! Int > 0),
                       cadence: dict["cadence"] as! Int,
                       watts: Int(dict["watts"] as! Double),
                       watts_estimated: (dict["wattsEstimated"] as! Int > 0),
                       heart_rate: Int(dict["hr"] as! Double),
                       is_brick: (dict["brick"] as! Int > 0),
                       keywords: dict["keywords"] as? String ?? "",
                       comments: dict["comments"] as? String ?? "")
    }
    
    private func sleepQualityScore(forQuality quality: String) -> Double{
        switch quality{
        case "Excellent": return 1.0
        case "Good": return 0.75
        case "Average": return 0.5
        case "Poor": return 0.3
        case "Very Poor": return 0.1
        default: return 0.0
        }
    }
    
    private func progressString(percentage: Double, start: Date) -> String{
        let s: String = String(format: "%.2f%%", percentage*100)
        return "\(s) \(timeFormatter.string(from: Date().timeIntervalSince(start))!)"
    }

    
}
